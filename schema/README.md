# OpenSwitch schema format

This file describes the changes made to the schema, along with an explanation of
the files that are generated by this module.

Original discussion about the ***Schema Modularity*** started in
[this ops-dev mailing list thread](http://lists.openswitch.net/pipermail/ops-dev/2016-February/001731.html).
Even the final implementation is not fully compliant with the content suggested
in the discussion, it is an interesting point to understand the background on the
needs this new schema format must fulfill.

In order to split the schema the small pieces, several scripts were written to
automate the process. Those scripts can be found
[here](https://github.hpe.com/ops-smi/schema/tree/master).

> **Note**
>
> The new schema pieces were conviniently generated using a proper JSON
> indentation. Keep the same format when writing your own schemas.

## Table of content

1. [Definitions](#Definitions)
1. [Rationale](#Rationale)
  * [Schema readability](Schema readability)
  * [Schema validation](#Schema validation)
  * [Code generation](#Code generation)
  * [Database documentation](#Database documentation)
1. [Directory structure](#Directory structure)
1. [New schema format](#New schema format)
  * [Master and Unified schema](#Master and Unified schema)
  * [`emptyValue` element](#`emptyValue` element)
  * [`group` element](#`group` element)
  * [`doc` element](#`doc` element)
  * [`valueMap` element](#`valueMap` element)
  * [`valueType` element](`valueType` element)
1. [Validation](#Validation)
1. [Code generation](#Code generation)


## Definitions
| Term | Description
|---
| OVS  | Open vSwitch
| OPS  | OpenSwitch
| ovsschema | OVS schema
| extschema |  OPS schema. Also known as *extended schema*. It is an OpenSwitch version of the ovsschema which contains some JSON s to enable REST functionalities
| metaschema | set of rules described in JSON to validate the schema


## Rationale

### Schema readability

OpenSwitch schema contains many tables to meet the feature-specific
requirements. Keeping all that tables in a single big file is too difficult to
read, understand, and maintain. Since the schema is being described using
JavaScript Object Notation (JSON),
[JSON Pointers](https://tools.ietf.org/html/rfc6901) can be used to create
references to elements in other files to split the original content into small
pieces.

Original Open vSwitch schema is complemented with a XML file to document the
tables and columns and describe the keys names and the values data types in
the maps. It is hard to match the table structure in the schema with the
semantic described in the XML file.

### Schema validation

Schema resides in its own repository. However, ops-openvswitch performs
validations in the schema structure using simple heuristics written in a Python
script. Such validations are done when the ops-openvswitch module is built.
Although, the schema must be validated as soon as the changes get the
repository, instead of depending on the validation rules in the other
repository. Schema validation must be done during the `check` job and a similar
mechanism must be provided to the developer to be able to catch the errors
promptly.

Since the database schema uses JSON format, the validation process can be done
using a [meta-schema](https://tools.ietf.org/html/draft-zyp-json-schema-04) to
describe the general structure of the schema file. Main validation rules can be
described using the same JSON based format to also ease the understanding of
such rules.

### Code generation

All the symbols in the schema must be available for the feature daemons
code. Given some map columns names were only defined in the XML file, some
symbols were not being generated. Developers had to manually maintain a file
to make them available during the build process.

`emptyValue` element introduced in the new schema format must also generate the
correspondent symbols to let the feature daemon use it in the code.

### Database documentation

A diagram/graph can be built to ease the readability and understanding of the
semantic described in the schema. By using the `refTable` and `refType` tags,
the diagram can provide a picture of how the tables relate and depend on each
other. Given the schema has several tables with *complex relationships*, a
single diagram containing everything is impossible to read. Therefore, diagrams
are split per table, showing the connections to the

Documentation must be easily navigated using Markdown or HTML files. Generated
files can be used locally or installed in **TODO: put the location here**.


## New schema format

### Master and Unified files

The **master.extschema.json** is a JSON file containing the references to the
tables that compose the database schema. It also contains a reference to the
group documentation. This master file is the one used by the scripts to create
an unified file where the references were resolved.

The **unified.extschema.json** file is not part of the repository because is a
generated file during the build process. Although, the unified file is deployed
as part of the image since `ops-restd` uses it instead of the old extschema.

```javascript
{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "id": "master.extschema.json#",
  "name": "OpenSwitch",
  "version": "0.1.8",
  "groups": {
    "$ref": "docs/groups.extschema.json#/groups"
  },
  "tables": {
    "System": {
      "$ref": "common/system.json#/tables/System"
    },
    "Subsystem": {
      "$ref": "common/subsystem.json#/tables/Subsystem"
    },
    "Bridge": {
      "$ref": "common/bridge.json#/tables/Bridge"
    }
    # More tables...
  }
}
```
Note that JSON pointers are used to create a link to the specific elements on
the target file. Thus, the content of the `groups` will be extracted from the
`groups` element in the file `groups.extschema.json` in the directory
`docs`. Same applies for the table `System` whose content will be extracted
from `System` element inside of the `tables` element in the file `system.json`
in the directory `common`.

### `emptyValue` element

This element describe the value to be used in case an optional column or a map
key is not set. It lets the developer know the value of an element when the
it is not present in a notification. Thus, daemons do not have to hardcode the
value in its side because the info can be extracted from the schema.

The empty values are being generated as a C header file as part of this
module's build process in the `ops-empty-values.h` file.

> **TODO**: `emptyValue` must be integrated in the ovsdb_idl_class static data
structure to make them available in runtime, as the max/min,
maxInteger/minInteger, and maxLength/minLength are.

#### Format
```javascript
"emptyValue": <JSON-value>
```

> `<JSON-value>` must be specified using a valid JSON data type. `emptyValue`
> data type is defined by the column's `type` element or map's `valueType`
> element.

### `group` element

This element is used to put the tables/columns/maps inside a specific group.
It defines a logical grouping to put the schema element together, to easy the
understanding of the semantic described in the database schema.

To create a group, use the same hierarchical string tag in more than one
database schema element within the same category (you cannot put elements in
the same group if they are located in different tables, columns, or maps).

Optionally, the group may have a general description in
`docs/groups.extschema.json`.

#### Format
```javascript
"group": <string>
```

> Given the group value is a simple string, any valid character is allowed
> here. Hierarchical organization allows to detail each element to add
> descriptions to the group when the documentation is generated.

### `doc` element

This element contains the documentation of a table, column, map, or group. The
original HTML content in the XML file was converted into Markdown format and
added as an array of lines.

#### Format
```javascript
"doc": [
  <string>,
  <string>,
  ...
]
```

> Documentation lines were wrapped to *80 characters per line*. Keep the same
> format when adding more lines, no matters how many lines


### `valueMap` element

This new element is used to specify the key names in a column map and the
details related to them. It merges the information in the old schema and the
documentation in the old XML file. It is located under the `type` element in
column.

```javascript
"valueMap": {
  "key_1": {
    "type": <JSON-datatype>,
    "doc": [
      "line 1",
      "line 2"
    ],
    "group": "/Path/To/Group"
  },
  "key_2": {
    "type": {
      "type": "integer",
      "minInteger": <JSON-value>,
      "maxInteger": <JSON-value>
    },
    "doc": [
      "line 1"
    ],
    "group": "/Path/To/Group",
    "emptyValue": <JSON-value>
  }

```


### `valueType` element

This element describes the data type to be used in the entire map. Given the map
elements can define its own specific data type internallly for each key name,
this element allows to define a data type for every element in the map (required
for the code generation).

#### Format
```javascript
"valueType": <string>
```


## Validation

The meta-schema to perform the validation is stored in
`openswitch.metaschema.json`.

## Code generation

`ops-oenvswitch` provides a mechanism to generate the code to let the daemons
know about the definitions in the schema (enumerations, map keys). These values
are generated in the `vswitch-idl.h` file during the `ops-openswitch` build
process.

However, since the `emptyValue` element was introduced by OPS, `ops-openvswitch`
cannot generate the definitions for them. Therefore, a script was provided to
generate the `ops-empty-values.h` header file containing such values.
